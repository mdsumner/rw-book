[
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Preface",
    "section": "",
    "text": "Preface\nThis is a Quarto book about geospatial data structures in R and Python (and other languages).\nThe book started with the idea that there is a fundamental value in the concept of a regular grid and that, this is not as well understood as it should be."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nThis is a book about gridded data which includes scientific arrays, imagery, earth observation data, and model output.\nWe will explore ease of use and redundancy in software and try to draw some seemingly incongruous threads and topics together in R and other languages."
  },
  {
    "objectID": "r-image.html",
    "href": "r-image.html",
    "title": "R and image",
    "section": "",
    "text": "R and image\nBase R has since at least 1998 had the volcano dataset (a 61x87 matrix of integer heights from Mauna Whau) and the image() function.\nThe image() function takes matrix and draws it by mapping a numerical value in matrix elements to a colour intensity on the screen.\n\nimage(volcano)\n\n\n\n\nNo georeferencing information is included with the dataset other than that it was hand digitized from a map and that the pixel size is 10m either side. So in this plot there is 870 in the x direction, and 610m in the y direction but here image() defaults to the unit square (which is shame because we have lost all sense of the aspect ratio). Also if you know what Mauna Whau usually looks like on a north-up map you’ll know that it seems rotated (90 degrees clockwise) from that.\nWe know that the dataset has extent 2667400, 2668010, 6478700, 6479570 (xmin, xmax, ymin, ymax) on New Zealand Map Grid (NZGD49 / New Zealand Map Grid (EPSG:27200)).\nTo plot with image() we must generate the 1D-coord arrays that position the matrix in this extent.\n\nex &lt;- c(2667400, 2668010, 6478700, 6479570)\nxs &lt;- seq(ex[1L], ex[2L], length.out = 61L + 1L)\nys &lt;- seq(ex[3L], ex[4L], length.out = 87L + 1L)\nimage(xs, ys, t(volcano[,  61:1]), asp = 1)\n\n\n\n\nWe know this is correct, but we’ll prove it also by obtaining some imagery data from online and overplotting our volcano dataset.\n\nlibrary(ximage)\nlibrary(whatarelief)\nim &lt;- imagery(extent = ex, dimension = c(610L, 870L), projection = \"EPSG:27200\")\nximage(im, ex, asp = 1)\nxc &lt;- xs[-length(xs)] + diff(xs[1:2])/2\nyc &lt;- ys[-length(xs)] + diff(ys[1:2])/2\ncontour(xc, yc, t(volcano[,  61:1]), add = TRUE, col = \"hotpink\")\n\n\n\n\nNote here that we have had to convert from referencing to the edges of the pixels to referencing to the centres for using contour. This is an inconsistency deep in R itself, and is just one example of the complex of problems that inspired the topic of this book."
  },
  {
    "objectID": "ghrsst-netcdf.html",
    "href": "ghrsst-netcdf.html",
    "title": "A geospatial dataset in NetCDF",
    "section": "",
    "text": "GHRSST is a high resolution globally-complete oceanographic dataset of sea surface temperature. It is strictly a 2d product, published daily since July 2002 and records temperature in Kelvin at the ocean surface, a blended product of observations, satellite data, and models. The dimension of the grid in pixels is 36000x17999. The storage format is NetCDF, with ‘time’ as an unlimited dimension recorded in the file - each file has a single 3D time step in the typical way that NetCDF includes and “UNLIMITED” dimension that will be appended to continually in future.\nGHRSST has a bit of a broken grid, the coordinates are degenerate rectilinear (i.e. completely described by the grid in xmin,xmax,ymin,ymax and the dimensions 36000x17999 but they store the longitude and latitude 1D coordinate arrays materalized as 32-bit floating point with resultant noise). It’s not clear how the grid should be aligned exactly, and the metadata attributes list -180,180, -90,90 as the valid range but this can’t be correct at 0.01 degree resolution for that size grid).\nSee the (ncdump -h listed below).\n\n## replace this local file with the one at the new earthdata store commented out (but you need your earthdata creds, or Authorization Bearer token)\nncsrc &lt;- \"/rdsi/PUBLIC/raad/data/podaac-opendap.jpl.nasa.gov/opendap/allData/ghrsst/data/GDS2/L4/GLOB/JPL/MUR/v4.1/2002/152/20020601090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc\"\n## https://cmr.earthdata.nasa.gov/virtual-directory/collections/C1996881146-POCLOUD/temporal/2002/05/31\n## https://archive.podaac.earthdata.nasa.gov/podaac-ops-cumulus-protected/MUR-JPL-L4-GLOB-v4.1/20020601090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc\n\n## read the lon,lat 1D arrays from the file (every file stores these 36000 lons and 17999 lats with ostensibly 0.01 spacing\nlibrary(RNetCDF)\ncon &lt;- open.nc(ncsrc)\n\nopen the file\nexpand file name\nDONE: expand file name\n\nlat &lt;- var.get.nc(con, \"lat\")\nlon &lt;- var.get.nc(con, \"lon\")\nclose.nc(con)\n\n## weirdly right-edge aligned\nprint(range(lon))\n\n[1] -179.99  180.00\n\n## these are ok, but we miss half a cell from -90/90 (hence the 17999 thing, but why did they do that?)\nprint(range(lat))\n\n[1] -89.99  89.99\n\n## there's noise in the values\nplot(diff(lon), pch = \".\")\nformat(range(diff(lon)), digits = 16)\n\n[1] \"0.0099945068359375\" \"0.0100097656250000\"\n\n## and it's way more noise than in Float64\npoints(diff(fixlon &lt;- seq(-179.995, 179.995, by = 0.01)), pch = \".\",  col = \"red\")\n\n\n\n\n\nformat(range(diff(fixlon)), digits = 16)\n\n[1] \"0.009999999999990905\" \"0.010000000000047748\"\n\nrange(fixlon); length(fixlon)\n\n[1] -179.995  179.995\n\n\n[1] 36000\n\ngdalex &lt;- vapour::vapour_raster_info(sprintf(\"NetCDF:%s:analysed_sst\", ncsrc))$extent\n\nfixex &lt;- c(-180, -180, -89.995, 89.995)\n\n## ewk\nformat(gdalex, digits = 16)\n\n[1] \"-179.9950055\" \" 180.0050000\" \" -89.9949979\" \"  89.9949979\"\n\n\nNow we plot the points - see description above the figure.\n\npar(mfrow = c(2, 2))\n\n## UL --------------------------------------------------------------------------\nplot(NA, xlim = c(-180, -179.95), ylim = c(89.95, 90), asp = 1, xlab = \"lon\", ylab = \"lat\")\ntitle(\"UL: upper left\")\n\nabline(v = -180, h = 90)\nabline(h = fixex[3:4], lty =  2)\npoints(expand.grid(head(lon), tail(lat)))\nvaster::plot_extent(gdalex, border = \"red\", add = TRUE)\n\n\n## UR --------------------------------------------------------------------------\nplot(NA, xlim = c(179.95, 180), ylim = c(89.95, 90), asp = 1, xlab = \"lon\", ylab = \"lat\")\ntitle(\"UR: upper right\")\n\nabline(v = 180, h = 90)\nabline(h = fixex[3:4], lty =  2)\npoints(expand.grid(tail(lon), tail(lat)))\nvaster::plot_extent(gdalex, border = \"red\", add = TRUE)\n## LL --------------------------------------------------------------------------\nplot(NA, xlim = c(-180, -179.95), ylim = c(-90, -89.95), asp = 1, xlab = \"lon\", ylab = \"lat\")\ntitle(\"LL: lower left\")\n\nabline(v = -180, h = -90)\nabline(h = fixex[3:4], lty =  2)\npoints(expand.grid(head(lon), head(lat)))\nvaster::plot_extent(gdalex, border = \"red\", add = TRUE)\n## LR --------------------------------------------------------------------------\nplot(NA, xlim = c(179.95, 180), ylim = c(-90, -89.95), asp = 1, xlab = \"lon\", ylab = \"lat\")\nabline(v = 180, h = -90)\ntitle(\"LR: lower right\")\n\nabline(h = fixex[3:4], lty =  2)\npoints(expand.grid(tail(lon), head(lat)))\nvaster::plot_extent(gdalex, border = \"red\", add = TRUE, xlab = \"lon\", ylab = \"lat\")\n\n\n\n\nThese points are the implicit pairs by expanding lon,lat from the file and compare what GDAL derives as the extent (red), and the vertical black lines is -180,180,-90,90. The hatched line is what we think should be assigned (an implicit missing row, split half at the top and bottom) - close enough to GDAL but with the longitude fixed and the extent made tidy (resolution 0.01, aligned to 0).\n\n\nto fix all that up for a GDAL reader I do\n'vrt://{ncsrc}?a_ullr=-180,89.995,180,-89.995&a_srs=EPSG:4326&a_offset=25&a_scale=0.001&sd_name=analysed_sst'\nthe a_scale/offset mean we get Celsius from the Int16 rather than Fahrenheit, the a_ullr fixes the regular extent and avoids all the numeric fuzz and redundancy of the lon,lat arrays, sd_name means we don’t need the ‘NETCDF:dsn:variable’ prefix:suffix stuff for the GDAL subdataset (but only since GDAL 3.9.0), and a_srs means we can churn through the warper for lovely new grids of any extent and dimension and crs we like.\nAnother option would be to specify a target grid and let GDAL warp from the geolocation arrays.\n\n\n\ngdalinfo on the file reports\n\nsystem(sprintf(\"gdalinfo %s\", ncsrc))\n\nThe the GEOLOCATION section, it knows about those 1D arrays.\nSo then we can do\nsubdataset modify metadata specify grid and resample method\n\nsystem(sprintf(\"gdalwarp %s ghrsst.tif\", nsrc))\n## Netcdf summary\n\nncdump -sh\nnetcdf \\20020601090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1 {\ndimensions:\n    time = 1 ;\n    lat = 17999 ;\n    lon = 36000 ;\nvariables:\n    int time(time) ;\n        time:long_name = \"reference time of sst field\" ;\n        time:standard_name = \"time\" ;\n        time:axis = \"T\" ;\n        time:units = \"seconds since 1981-01-01 00:00:00 UTC\" ;\n        time:comment = \"Nominal time of analyzed fields\" ;\n        time:_Storage = \"contiguous\" ;\n        time:_Endianness = \"little\" ;\n    float lat(lat) ;\n        lat:long_name = \"latitude\" ;\n        lat:standard_name = \"latitude\" ;\n        lat:axis = \"Y\" ;\n        lat:units = \"degrees_north\" ;\n        lat:valid_min = -90.f ;\n        lat:valid_max = 90.f ;\n        lat:comment = \"none\" ;\n        lat:_Storage = \"chunked\" ;\n        lat:_ChunkSizes = 17999 ;\n        lat:_DeflateLevel = 7 ;\n        lat:_Shuffle = \"true\" ;\n        lat:_Endianness = \"little\" ;\n    float lon(lon) ;\n        lon:long_name = \"longitude\" ;\n        lon:standard_name = \"longitude\" ;\n        lon:axis = \"X\" ;\n        lon:units = \"degrees_east\" ;\n        lon:valid_min = -180.f ;\n        lon:valid_max = 180.f ;\n        lon:comment = \"none\" ;\n        lon:_Storage = \"chunked\" ;\n        lon:_ChunkSizes = 36000 ;\n        lon:_DeflateLevel = 7 ;\n        lon:_Shuffle = \"true\" ;\n        lon:_Endianness = \"little\" ;\n    short analysed_sst(time, lat, lon) ;\n        analysed_sst:long_name = \"analysed sea surface temperature\" ;\n        analysed_sst:standard_name = \"sea_surface_foundation_temperature\" ;\n        analysed_sst:units = \"kelvin\" ;\n        analysed_sst:_FillValue = -32768s ;\n        analysed_sst:add_offset = 298.15 ;\n        analysed_sst:scale_factor = 0.001 ;\n        analysed_sst:valid_min = -32767s ;\n        analysed_sst:valid_max = 32767s ;\n        analysed_sst:comment = \"\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolation\" ;\n        analysed_sst:coordinates = \"lon lat\" ;\n        analysed_sst:source = \"AMSRE-REMSS, AVHRR_Pathfinder-PFV5.2-NODC_day, AVHRR_Pathfinder-PFV5.2-NODC_night, MODIS_T-JPL, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\" ;\n        analysed_sst:_Storage = \"chunked\" ;\n        analysed_sst:_ChunkSizes = 1, 1023, 2047 ;\n        analysed_sst:_DeflateLevel = 7 ;\n        analysed_sst:_Shuffle = \"true\" ;\n        analysed_sst:_Endianness = \"little\" ;\n    short analysis_error(time, lat, lon) ;\n        analysis_error:long_name = \"estimated error standard deviation of analysed_sst\" ;\n        analysis_error:units = \"kelvin\" ;\n        analysis_error:_FillValue = -32768s ;\n        analysis_error:add_offset = 0. ;\n        analysis_error:scale_factor = 0.01 ;\n        analysis_error:valid_min = 0s ;\n        analysis_error:valid_max = 32767s ;\n        analysis_error:comment = \"none\" ;\n        analysis_error:coordinates = \"lon lat\" ;\n        analysis_error:_Storage = \"chunked\" ;\n        analysis_error:_ChunkSizes = 1, 1023, 2047 ;\n        analysis_error:_DeflateLevel = 7 ;\n        analysis_error:_Shuffle = \"true\" ;\n        analysis_error:_Endianness = \"little\" ;\n    byte mask(time, lat, lon) ;\n        mask:long_name = \"sea/land field composite mask\" ;\n        mask:_FillValue = -128b ;\n        mask:valid_min = 1b ;\n        mask:valid_max = 31b ;\n        mask:flag_masks = 1b, 2b, 4b, 8b, 16b ;\n        mask:flag_values = 1b, 2b, 5b, 9b, 13b ;\n        mask:flag_meanings = \"1=open-sea, 2=land, 5=open-lake, 9=open-sea with ice in the grid, 13=open-lake with ice in the grid\" ;\n        mask:comment = \"mask can be used to further filter the data.\" ;\n        mask:coordinates = \"lon lat\" ;\n        mask:source = \"GMT \\\"grdlandmask\\\", ice flag from sea_ice_fraction data\" ;\n        mask:_Storage = \"chunked\" ;\n        mask:_ChunkSizes = 1, 1447, 2895 ;\n        mask:_DeflateLevel = 7 ;\n        mask:_Shuffle = \"true\" ;\n    byte sea_ice_fraction(time, lat, lon) ;\n        sea_ice_fraction:long_name = \"sea ice area fraction\" ;\n        sea_ice_fraction:standard_name = \"sea ice area fraction\" ;\n        sea_ice_fraction:units = \"fraction (between 0 and 1)\" ;\n        sea_ice_fraction:_FillValue = -128b ;\n        sea_ice_fraction:add_offset = 0. ;\n        sea_ice_fraction:scale_factor = 0.01 ;\n        sea_ice_fraction:valid_min = 0b ;\n        sea_ice_fraction:valid_max = 100b ;\n        sea_ice_fraction:source = \"EUMETSAT OSI-SAF, copyright EUMETSAT\" ;\n        sea_ice_fraction:comment = \"ice data interpolated by a nearest neighbor approach.\" ;\n        sea_ice_fraction:coordinates = \"lon lat\" ;\n        sea_ice_fraction:_Storage = \"chunked\" ;\n        sea_ice_fraction:_ChunkSizes = 1, 1447, 2895 ;\n        sea_ice_fraction:_DeflateLevel = 7 ;\n        sea_ice_fraction:_Shuffle = \"true\" ;\n\n// global attributes:\n        :Conventions = \"CF-1.5\" ;\n        :title = \"Daily MUR SST, Final product\" ;\n        :summary = \"A merged, multi-sensor L4 Foundation SST analysis product from JPL.\" ;\n        :references = \"http://podaac.jpl.nasa.gov/Multi-scale_Ultra-high_Resolution_MUR-SST\" ;\n        :institution = \"Jet Propulsion Laboratory\" ;\n        :history = \"created at nominal 4-day latency; replaced nrt (1-day latency) version.\" ;\n        :comment = \"MUR = \\\"Multi-scale Ultra-high Reolution\\\"\" ;\n        :license = \"These data are available free of charge under data policy of JPL PO.DAAC.\" ;\n        :id = \"MUR-JPL-L4-GLOB-v04.1\" ;\n        :naming_authority = \"org.ghrsst\" ;\n        :product_version = \"04.1\" ;\n        :uuid = \"27665bc0-d5fc-11e1-9b23-0800200c9a66\" ;\n        :gds_version_id = \"2.0\" ;\n        :netcdf_version_id = \"4.1\" ;\n        :date_created = \"20150819T103929Z\" ;\n        :start_time = \"20020601T090000Z\" ;\n        :stop_time = \"20020601T090000Z\" ;\n        :time_coverage_start = \"20020531T210000Z\" ;\n        :time_coverage_end = \"20020601T210000Z\" ;\n        :file_quality_level = \"1\" ;\n        :source = \"AMSRE-REMSS, AVHRR_Pathfinder-PFV5.2-NODC_day, AVHRR_Pathfinder-PFV5.2-NODC_night, MODIS_T-JPL, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\" ;\n        :platform = \"Aqua, DMSP, NOAA-POES, Suomi-NPP, Terra\" ;\n        :sensor = \"AMSR-E, AVHRR, MODIS, SSM/I, VIIRS, in-situ\" ;\n        :Metadata_Conventions = \"Unidata Observation Dataset v1.0\" ;\n        :metadata_link = \"http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MUR-JPL-L4-GLOB-v04.1\" ;\n        :keywords = \"Oceans &gt; Ocean Temperature &gt; Sea Surface Temperature\" ;\n        :keywords_vocabulary = \"NASA Global Change Master Directory (GCMD) Science Keywords\" ;\n        :standard_name_vocabulary = \"NetCDF Climate and Forecast (CF) Metadata Convention\" ;\n        :southernmost_latitude = -90.f ;\n        :northernmost_latitude = 90.f ;\n        :westernmost_longitude = -180.f ;\n        :easternmost_longitude = 180.f ;\n        :spatial_resolution = \"0.01 degrees\" ;\n        :geospatial_lat_units = \"degrees north\" ;\n        :geospatial_lat_resolution = \"0.01 degrees\" ;\n        :geospatial_lon_units = \"degrees east\" ;\n        :geospatial_lon_resolution = \"0.01 degrees\" ;\n        :acknowledgment = \"Please acknowledge the use of these data with the following statement:  These data were provided by JPL under support by NASA MEaSUREs program.\" ;\n        :creator_name = \"JPL MUR SST project\" ;\n        :creator_email = \"ghrsst@podaac.jpl.nasa.gov\" ;\n        :creator_url = \"http://mur.jpl.nasa.gov\" ;\n        :project = \"NASA Making Earth Science Data Records for Use in Research Environments (MEaSUREs) Program\" ;\n        :publisher_name = \"GHRSST Project Office\" ;\n        :publisher_url = \"http://www.ghrsst.org\" ;\n        :publisher_email = \"ghrsst-po@nceo.ac.uk\" ;\n        :processing_level = \"L4\" ;\n        :cdm_data_type = \"grid\" ;\n        :_SuperblockVersion = 2 ;\n        :_IsNetcdf4 = 1 ;\n        :_Format = \"netCDF-4\" ;\n\n\n\nEssentially floating point numbers struggle with precision for longitude and latitude (we might rescale closer to integers, but that’s tricky for metadata).\nto bring home the point about the single precision (I think this is right, appreciate if anyone points out a mistake or misunderstanding)\nGenerate the coord values first in double precision, then in single (in R we have to return doubles, but the calc is done in float for the second one).\n\nlibrary(cpp11)\ncpp_function('\ndoubles coord64(double start, int len, double step) {\n   writable::doubles out = writable::doubles(len); \n   for (int i = 0; i &lt; len; i++) {\n     out[i] = start + i * step; \n   }\n   return out ;\n}\n             ')\n\nrange(lon64 &lt;- coord64(-179.99, 36000, 0.01))\n\n[1] -179.99  180.00\n\nformat(range(diff(lon64)), digits = 16)\n\n[1] \"0.009999999999990905\" \"0.010000000000047748\"\n\nrange(lat64 &lt;- coord64(-89.99, 17999, 0.01))\n\n[1] -89.99  89.99\n\nformat(range(diff(lat64)), digits = 16)\n\n[1] \"0.009999999999990905\" \"0.010000000000019327\"\n\ncpp_function('\n\ndoubles coord32(float start, int len, float step) {\n  writable::doubles out = writable::doubles(len); \n  for (int i = 0; i &lt; len; i++) {\n    out[i] = start + i * step; \n  }\n  return out ;\n}\n')\n\nrange(lon32 &lt;- coord32(-179.99, 36000, 0.01))\n\n[1] -179.99  180.00\n\nformat(range(diff(lon32)), digits = 16)\n\n[1] \"0.009979248046875\" \"0.010009765625000\"\n\nrange(lat32 &lt;- coord32(-89.99, 17999, 0.01))\n\n[1] -89.99  89.99\n\nformat(range(diff(lat32)), digits = 16)\n\n[1] \"0.0099945068359375\" \"0.0100097656250000\""
  },
  {
    "objectID": "ghrsst-netcdf.html#a-fix",
    "href": "ghrsst-netcdf.html#a-fix",
    "title": "A geospatial dataset in NetCDF",
    "section": "",
    "text": "to fix all that up for a GDAL reader I do\n'vrt://{ncsrc}?a_ullr=-180,89.995,180,-89.995&a_srs=EPSG:4326&a_offset=25&a_scale=0.001&sd_name=analysed_sst'\nthe a_scale/offset mean we get Celsius from the Int16 rather than Fahrenheit, the a_ullr fixes the regular extent and avoids all the numeric fuzz and redundancy of the lon,lat arrays, sd_name means we don’t need the ‘NETCDF:dsn:variable’ prefix:suffix stuff for the GDAL subdataset (but only since GDAL 3.9.0), and a_srs means we can churn through the warper for lovely new grids of any extent and dimension and crs we like.\nAnother option would be to specify a target grid and let GDAL warp from the geolocation arrays."
  },
  {
    "objectID": "ghrsst-netcdf.html#geolocation-arrays",
    "href": "ghrsst-netcdf.html#geolocation-arrays",
    "title": "A geospatial dataset in NetCDF",
    "section": "",
    "text": "gdalinfo on the file reports\n\nsystem(sprintf(\"gdalinfo %s\", ncsrc))\n\nThe the GEOLOCATION section, it knows about those 1D arrays.\nSo then we can do\nsubdataset modify metadata specify grid and resample method\n\nsystem(sprintf(\"gdalwarp %s ghrsst.tif\", nsrc))\n## Netcdf summary\n\nncdump -sh\nnetcdf \\20020601090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1 {\ndimensions:\n    time = 1 ;\n    lat = 17999 ;\n    lon = 36000 ;\nvariables:\n    int time(time) ;\n        time:long_name = \"reference time of sst field\" ;\n        time:standard_name = \"time\" ;\n        time:axis = \"T\" ;\n        time:units = \"seconds since 1981-01-01 00:00:00 UTC\" ;\n        time:comment = \"Nominal time of analyzed fields\" ;\n        time:_Storage = \"contiguous\" ;\n        time:_Endianness = \"little\" ;\n    float lat(lat) ;\n        lat:long_name = \"latitude\" ;\n        lat:standard_name = \"latitude\" ;\n        lat:axis = \"Y\" ;\n        lat:units = \"degrees_north\" ;\n        lat:valid_min = -90.f ;\n        lat:valid_max = 90.f ;\n        lat:comment = \"none\" ;\n        lat:_Storage = \"chunked\" ;\n        lat:_ChunkSizes = 17999 ;\n        lat:_DeflateLevel = 7 ;\n        lat:_Shuffle = \"true\" ;\n        lat:_Endianness = \"little\" ;\n    float lon(lon) ;\n        lon:long_name = \"longitude\" ;\n        lon:standard_name = \"longitude\" ;\n        lon:axis = \"X\" ;\n        lon:units = \"degrees_east\" ;\n        lon:valid_min = -180.f ;\n        lon:valid_max = 180.f ;\n        lon:comment = \"none\" ;\n        lon:_Storage = \"chunked\" ;\n        lon:_ChunkSizes = 36000 ;\n        lon:_DeflateLevel = 7 ;\n        lon:_Shuffle = \"true\" ;\n        lon:_Endianness = \"little\" ;\n    short analysed_sst(time, lat, lon) ;\n        analysed_sst:long_name = \"analysed sea surface temperature\" ;\n        analysed_sst:standard_name = \"sea_surface_foundation_temperature\" ;\n        analysed_sst:units = \"kelvin\" ;\n        analysed_sst:_FillValue = -32768s ;\n        analysed_sst:add_offset = 298.15 ;\n        analysed_sst:scale_factor = 0.001 ;\n        analysed_sst:valid_min = -32767s ;\n        analysed_sst:valid_max = 32767s ;\n        analysed_sst:comment = \"\\\"Final\\\" version using Multi-Resolution Variational Analysis (MRVA) method for interpolation\" ;\n        analysed_sst:coordinates = \"lon lat\" ;\n        analysed_sst:source = \"AMSRE-REMSS, AVHRR_Pathfinder-PFV5.2-NODC_day, AVHRR_Pathfinder-PFV5.2-NODC_night, MODIS_T-JPL, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\" ;\n        analysed_sst:_Storage = \"chunked\" ;\n        analysed_sst:_ChunkSizes = 1, 1023, 2047 ;\n        analysed_sst:_DeflateLevel = 7 ;\n        analysed_sst:_Shuffle = \"true\" ;\n        analysed_sst:_Endianness = \"little\" ;\n    short analysis_error(time, lat, lon) ;\n        analysis_error:long_name = \"estimated error standard deviation of analysed_sst\" ;\n        analysis_error:units = \"kelvin\" ;\n        analysis_error:_FillValue = -32768s ;\n        analysis_error:add_offset = 0. ;\n        analysis_error:scale_factor = 0.01 ;\n        analysis_error:valid_min = 0s ;\n        analysis_error:valid_max = 32767s ;\n        analysis_error:comment = \"none\" ;\n        analysis_error:coordinates = \"lon lat\" ;\n        analysis_error:_Storage = \"chunked\" ;\n        analysis_error:_ChunkSizes = 1, 1023, 2047 ;\n        analysis_error:_DeflateLevel = 7 ;\n        analysis_error:_Shuffle = \"true\" ;\n        analysis_error:_Endianness = \"little\" ;\n    byte mask(time, lat, lon) ;\n        mask:long_name = \"sea/land field composite mask\" ;\n        mask:_FillValue = -128b ;\n        mask:valid_min = 1b ;\n        mask:valid_max = 31b ;\n        mask:flag_masks = 1b, 2b, 4b, 8b, 16b ;\n        mask:flag_values = 1b, 2b, 5b, 9b, 13b ;\n        mask:flag_meanings = \"1=open-sea, 2=land, 5=open-lake, 9=open-sea with ice in the grid, 13=open-lake with ice in the grid\" ;\n        mask:comment = \"mask can be used to further filter the data.\" ;\n        mask:coordinates = \"lon lat\" ;\n        mask:source = \"GMT \\\"grdlandmask\\\", ice flag from sea_ice_fraction data\" ;\n        mask:_Storage = \"chunked\" ;\n        mask:_ChunkSizes = 1, 1447, 2895 ;\n        mask:_DeflateLevel = 7 ;\n        mask:_Shuffle = \"true\" ;\n    byte sea_ice_fraction(time, lat, lon) ;\n        sea_ice_fraction:long_name = \"sea ice area fraction\" ;\n        sea_ice_fraction:standard_name = \"sea ice area fraction\" ;\n        sea_ice_fraction:units = \"fraction (between 0 and 1)\" ;\n        sea_ice_fraction:_FillValue = -128b ;\n        sea_ice_fraction:add_offset = 0. ;\n        sea_ice_fraction:scale_factor = 0.01 ;\n        sea_ice_fraction:valid_min = 0b ;\n        sea_ice_fraction:valid_max = 100b ;\n        sea_ice_fraction:source = \"EUMETSAT OSI-SAF, copyright EUMETSAT\" ;\n        sea_ice_fraction:comment = \"ice data interpolated by a nearest neighbor approach.\" ;\n        sea_ice_fraction:coordinates = \"lon lat\" ;\n        sea_ice_fraction:_Storage = \"chunked\" ;\n        sea_ice_fraction:_ChunkSizes = 1, 1447, 2895 ;\n        sea_ice_fraction:_DeflateLevel = 7 ;\n        sea_ice_fraction:_Shuffle = \"true\" ;\n\n// global attributes:\n        :Conventions = \"CF-1.5\" ;\n        :title = \"Daily MUR SST, Final product\" ;\n        :summary = \"A merged, multi-sensor L4 Foundation SST analysis product from JPL.\" ;\n        :references = \"http://podaac.jpl.nasa.gov/Multi-scale_Ultra-high_Resolution_MUR-SST\" ;\n        :institution = \"Jet Propulsion Laboratory\" ;\n        :history = \"created at nominal 4-day latency; replaced nrt (1-day latency) version.\" ;\n        :comment = \"MUR = \\\"Multi-scale Ultra-high Reolution\\\"\" ;\n        :license = \"These data are available free of charge under data policy of JPL PO.DAAC.\" ;\n        :id = \"MUR-JPL-L4-GLOB-v04.1\" ;\n        :naming_authority = \"org.ghrsst\" ;\n        :product_version = \"04.1\" ;\n        :uuid = \"27665bc0-d5fc-11e1-9b23-0800200c9a66\" ;\n        :gds_version_id = \"2.0\" ;\n        :netcdf_version_id = \"4.1\" ;\n        :date_created = \"20150819T103929Z\" ;\n        :start_time = \"20020601T090000Z\" ;\n        :stop_time = \"20020601T090000Z\" ;\n        :time_coverage_start = \"20020531T210000Z\" ;\n        :time_coverage_end = \"20020601T210000Z\" ;\n        :file_quality_level = \"1\" ;\n        :source = \"AMSRE-REMSS, AVHRR_Pathfinder-PFV5.2-NODC_day, AVHRR_Pathfinder-PFV5.2-NODC_night, MODIS_T-JPL, iQUAM-NOAA/NESDIS, Ice_Conc-OSISAF\" ;\n        :platform = \"Aqua, DMSP, NOAA-POES, Suomi-NPP, Terra\" ;\n        :sensor = \"AMSR-E, AVHRR, MODIS, SSM/I, VIIRS, in-situ\" ;\n        :Metadata_Conventions = \"Unidata Observation Dataset v1.0\" ;\n        :metadata_link = \"http://podaac.jpl.nasa.gov/ws/metadata/dataset/?format=iso&shortName=MUR-JPL-L4-GLOB-v04.1\" ;\n        :keywords = \"Oceans &gt; Ocean Temperature &gt; Sea Surface Temperature\" ;\n        :keywords_vocabulary = \"NASA Global Change Master Directory (GCMD) Science Keywords\" ;\n        :standard_name_vocabulary = \"NetCDF Climate and Forecast (CF) Metadata Convention\" ;\n        :southernmost_latitude = -90.f ;\n        :northernmost_latitude = 90.f ;\n        :westernmost_longitude = -180.f ;\n        :easternmost_longitude = 180.f ;\n        :spatial_resolution = \"0.01 degrees\" ;\n        :geospatial_lat_units = \"degrees north\" ;\n        :geospatial_lat_resolution = \"0.01 degrees\" ;\n        :geospatial_lon_units = \"degrees east\" ;\n        :geospatial_lon_resolution = \"0.01 degrees\" ;\n        :acknowledgment = \"Please acknowledge the use of these data with the following statement:  These data were provided by JPL under support by NASA MEaSUREs program.\" ;\n        :creator_name = \"JPL MUR SST project\" ;\n        :creator_email = \"ghrsst@podaac.jpl.nasa.gov\" ;\n        :creator_url = \"http://mur.jpl.nasa.gov\" ;\n        :project = \"NASA Making Earth Science Data Records for Use in Research Environments (MEaSUREs) Program\" ;\n        :publisher_name = \"GHRSST Project Office\" ;\n        :publisher_url = \"http://www.ghrsst.org\" ;\n        :publisher_email = \"ghrsst-po@nceo.ac.uk\" ;\n        :processing_level = \"L4\" ;\n        :cdm_data_type = \"grid\" ;\n        :_SuperblockVersion = 2 ;\n        :_IsNetcdf4 = 1 ;\n        :_Format = \"netCDF-4\" ;"
  },
  {
    "objectID": "ghrsst-netcdf.html#demonstration-of-the-float32-precision-problem",
    "href": "ghrsst-netcdf.html#demonstration-of-the-float32-precision-problem",
    "title": "A geospatial dataset in NetCDF",
    "section": "",
    "text": "Essentially floating point numbers struggle with precision for longitude and latitude (we might rescale closer to integers, but that’s tricky for metadata).\nto bring home the point about the single precision (I think this is right, appreciate if anyone points out a mistake or misunderstanding)\nGenerate the coord values first in double precision, then in single (in R we have to return doubles, but the calc is done in float for the second one).\n\nlibrary(cpp11)\ncpp_function('\ndoubles coord64(double start, int len, double step) {\n   writable::doubles out = writable::doubles(len); \n   for (int i = 0; i &lt; len; i++) {\n     out[i] = start + i * step; \n   }\n   return out ;\n}\n             ')\n\nrange(lon64 &lt;- coord64(-179.99, 36000, 0.01))\n\n[1] -179.99  180.00\n\nformat(range(diff(lon64)), digits = 16)\n\n[1] \"0.009999999999990905\" \"0.010000000000047748\"\n\nrange(lat64 &lt;- coord64(-89.99, 17999, 0.01))\n\n[1] -89.99  89.99\n\nformat(range(diff(lat64)), digits = 16)\n\n[1] \"0.009999999999990905\" \"0.010000000000019327\"\n\ncpp_function('\n\ndoubles coord32(float start, int len, float step) {\n  writable::doubles out = writable::doubles(len); \n  for (int i = 0; i &lt; len; i++) {\n    out[i] = start + i * step; \n  }\n  return out ;\n}\n')\n\nrange(lon32 &lt;- coord32(-179.99, 36000, 0.01))\n\n[1] -179.99  180.00\n\nformat(range(diff(lon32)), digits = 16)\n\n[1] \"0.009979248046875\" \"0.010009765625000\"\n\nrange(lat32 &lt;- coord32(-89.99, 17999, 0.01))\n\n[1] -89.99  89.99\n\nformat(range(diff(lat32)), digits = 16)\n\n[1] \"0.0099945068359375\" \"0.0100097656250000\""
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  }
]